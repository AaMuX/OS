# 实验6：系统调用

**姓名**：XXX  
**学号**：2021xxxxx  
**日期**：2024-xx-xx  

---

## 一、实验概述

### 1. 实验目标

本实验旨在 **实现完整的系统调用框架**，重点理解以下内容：

- **用户态与内核态的切换机制**
- **系统调用的参数传递与返回值处理**
- **系统调用的安全性检查与错误处理**
- **进程控制与文件操作相关系统调用的实现**

通过本实验，加深对 **RISC-V 架构下系统调用流程** 以及 **xv6 操作系统设计思想** 的理解。

### 2. 完成情况

- ✅ **实现系统调用分发机制**（参数提取、调用路由、返回值处理）
- ✅ **完成进程相关系统调用**（`getpid`、`fork`、`wait`、`exit`）
- ✅ **完成文件相关系统调用**（`write`、`read`、`open`、`close` 等）
- ✅ **实现系统调用安全性检查**（无效指针检测、权限验证）
- ✅ **完成系统调用功能测试、安全性测试与性能测试**

### 3. 开发环境

- **操作系统**：Ubuntu 22.04 LTS  
- **工具链**：riscv64-unknown-elf-gcc 12.2.0  
- **模拟器**：QEMU qemu-system-riscv64 7.2.0  
- **参考源码**：xv6-riscv（commit: 9f21285）

---

## 二、技术设计

### 1. 系统架构设计

系统调用整体流程采用 **分层设计思想**，分为：

1. **用户态接口层**
2. **内核入口层**
3. **系统调用分发层**
4. **系统调用实现层**

整体流程如下：

```

[用户程序] → [系统调用桩函数] → [ecall指令] → [trap处理]
↓              ↓              ↓
参数入栈        特权级切换      上下文保存
↓              ↓              ↓
[内核系统调用分发器] → [参数验证] → [系统调用实现] → [结果返回]

````

#### 与 xv6 的主要区别

- **简化**：xv6 使用 `usys.pl` 自动生成桩代码，本实验中 **手动实现系统调用桩函数**
- **增强**：增加了 **更严格的参数合法性检查**（无效指针、负数长度过滤等）
- **统一**：将参数提取逻辑 **封装为通用机制**，减少冗余代码

---

### 2. 关键数据结构设计

#### （1）系统调用描述符表

```c
typedef struct {
    int (*handler)(uint64 a0, uint64 a1, uint64 a2); // 处理函数
    const char *name;                                 // 系统调用名称
    int arg_count;                                    // 参数个数
} syscall_desc_t;

static syscall_desc_t syscall_table[] = {
    {NULL, "invalid", 0},                // 0: 保留
    {sys_getpid, "getpid", 0},           // 1
    {sys_fork, "fork", 0},               // 2
    {sys_wait, "wait", 1},               // 3
    {sys_exit, "exit", 1},               // 4
    {sys_write, "write", 3},             // 5
    {sys_read, "read", 3},               // 6
    {sys_open, "open", 2},               // 7
    {sys_close, "close", 1},             // 8
    {sys_unlink, "unlink", 1},           // 9
    {sys_mkdir, "mkdir", 1},             // 10
};
````

**设计理由**：

1. **集中管理系统调用元信息**，便于扩展和调试
2. **显式记录参数个数**，为参数合法性检查提供依据
3. **存储系统调用名称**，支持系统调用日志输出

---

#### （2）系统调用上下文结构

```c
typedef struct {
    uint64 a0;   // 参数1 / 返回值
    uint64 a1;   // 参数2
    uint64 a2;   // 参数3
    uint64 a7;   // 系统调用号
    uint64 sepc; // 用户态返回地址
    uint64 sp;   // 用户态栈指针
} syscall_ctx_t;
```

**设计要点**：

* **抽取 trapframe 中的关键字段**
* **严格遵循 RISC-V 调用约定**
* 简化系统调用参数传递与返回值处理流程

---

### 3. 系统调用分发流程

```c
void syscall_dispatch(syscall_ctx_t *ctx) {
    int syscall_num = ctx->a7;
    struct proc *p = myproc();

    if (syscall_num <= 0 || syscall_num >= NELEM(syscall_table) ||
        syscall_table[syscall_num].handler == NULL) {
        printf("[ERROR] Invalid syscall %d (PID: %d)\n",
               syscall_num, p->pid);
        ctx->a0 = -1;
        return;
    }

    syscall_desc_t *desc = &syscall_table[syscall_num];
    ctx->a0 = desc->handler(ctx->a0, ctx->a1, ctx->a2);

    if (syscall_debug) {
        printf("[SYSCALL] PID: %d, call: %s, ret: %ld\n",
               p->pid, desc->name, ctx->a0);
    }
}
```

**与 xv6 对比**：

* xv6 使用 `argint` / `argstr` 提取参数
* 本实现直接通过 **系统调用上下文结构** 传递参数
* 增加 **统一日志输出与错误处理机制**

---

## 三、实现细节

### 1. 用户态系统调用桩函数

```c
static int syscall_wrapper(int num, uint64 a0, uint64 a1, uint64 a2) {
    register long t_a7 asm("a7") = num;
    register long t_a0 asm("a0") = a0;
    register long t_a1 asm("a1") = a1;
    register long t_a2 asm("a2") = a2;

    asm volatile(".4byte 0x00100073"
                 : "+r"(t_a0)
                 : "r"(t_a1), "r"(t_a2), "r"(t_a7)
                 : "memory");

    return t_a0;
}
```

**实现说明**：

* **a7 保存系统调用号**
* **a0–a2 传递参数**
* **a0 返回系统调用结果**
* 所有桩函数复用统一封装，降低冗余

---

### 2. 用户态内存安全访问

```c
static int check_user_ptr(const void *ptr, int size) {
    struct proc *p = myproc();
    uint64 va = (uint64)ptr;

    if (ptr == NULL && size != 0) return -1;
    if (va >= KERNBASE) return -1;
    if (size > 0 && va + size > p->sz) return -1;

    return 0;
}
```

**关键点**：

* **防止非法指针访问**
* **避免内核崩溃**
* **所有用户输入一律不可信**

---

### 3. write 系统调用实现

```c
int sys_write(uint64 a0, uint64 a1, uint64 a2) {
    int fd = (int)a0;
    char *buf = (char *)a1;
    int n = (int)a2;
    struct proc *p = myproc();

    if (fd < 0 || fd >= NOFILE || n < 0) return -1;
    if (n > 0 && check_user_ptr(buf, n) != 0) return -1;

    struct file *f = p->ofile[fd];
    if (f == NULL) return -1;

    return filewrite(f, buf, n);
}
```

---

## 四、测试与验证

### 1. 功能测试

#### 基础系统调用测试

```c
void test_basic_syscalls(void) {
    int pid = stub_getpid();
    int child = stub_fork();
    if (child == 0) {
        stub_exit(42);
    } else {
        int status;
        stub_wait(&status);
    }
}
```

**测试结果**：
系统调用功能正确，父子进程返回值符合预期。
![alt text](image.png)
---

### 2. 安全性测试

**无效指针测试** 成功拦截，返回 `-1`，未触发内核异常。
![alt text](image-1.png)
---

### 3. 性能测试

* **10000 次 getpid 调用**
* **平均每次约 12 个时钟周期**
* 性能开销较小，满足实验要求
![alt text](image-2.png)
---

## 五、问题与总结

### 1. 遇到的问题

* **fork 返回值处理错误**
* **用户态字符串未终止导致越界**
* **系统调用号定义不一致**

均已通过 **完善 trapframe 处理、增加边界检查、统一宏定义** 解决。

---

### 2. 实验收获

1. **深入理解系统调用机制**
2. **掌握 RISC-V 用户态 / 内核态切换**
3. **强化内核安全意识**
4. **提升分层设计与调试能力**

---

### 3. 改进方向

* 引入 **errno 错误码机制**
* 系统调用性能优化
* 支持更多系统调用（`pipe`、`mmap`）
* 实现系统调用跟踪与统计
