// Context switch
// 上下文切换函数
// 函数原型：void swtch(struct context *old, struct context *new);
// 功能：将当前寄存器保存到old，然后从new加载寄存器

  .text          // 代码段开始
  .globl swtch  // 声明swtch为全局符号
swtch:          // 函数入口
  // ====================
  // 第一部分：保存当前上下文
  // 将调用者的寄存器保存到old（a0寄存器）
  // 被调用者保存寄存器（s0-s11）由被调用函数负责保存
  // 调用者保存寄存器（a0-a7, t0-t6）已由编译器自动保存
  // ====================
  sd ra, 0(a0)   // 保存返回地址寄存器到old.ra
  sd sp, 8(a0)   // 保存栈指针寄存器到old.sp
  sd s0, 16(a0)  // 保存保存寄存器s0
  sd s1, 24(a0)  // 保存保存寄存器s1
  sd s2, 32(a0)  // 保存保存寄存器s2
  sd s3, 40(a0)  // 保存保存寄存器s3
  sd s4, 48(a0)  // 保存保存寄存器s4
  sd s5, 56(a0)  // 保存保存寄存器s5
  sd s6, 64(a0)  // 保存保存寄存器s6
  sd s7, 72(a0)  // 保存保存寄存器s7
  sd s8, 80(a0)  // 保存保存寄存器s8
  sd s9, 88(a0)  // 保存保存寄存器s9
  sd s10, 96(a0) // 保存保存寄存器s10
  sd s11, 104(a0) // 保存保存寄存器s11
  // 寄存器保存完成，当前执行现场已保存在内存中
  // 结构体struct context的布局与这里的内存偏移完全对应

  // ====================
  // 第二部分：恢复新上下文
  // 从new（a1寄存器）加载目标上下文的寄存器
  // 这实际上是切换到另一个线程/进程的上下文
  // ====================
  ld ra, 0(a1)   // 加载新的返回地址
  ld sp, 8(a1)   // 加载新的栈指针
  ld s0, 16(a1)  // 加载保存寄存器s0
  ld s1, 24(a1)  // 加载保存寄存器s1
  ld s2, 32(a1)  // 加载保存寄存器s2
  ld s3, 40(a1)  // 加载保存寄存器s3
  ld s4, 48(a1)  // 加载保存寄存器s4
  ld s5, 56(a1)  // 加载保存寄存器s5
  ld s6, 64(a1)  // 加载保存寄存器s6
  ld s7, 72(a1)  // 加载保存寄存器s7
  ld s8, 80(a1)  // 加载保存寄存器s8
  ld s9, 88(a1)  // 加载保存寄存器s9
  ld s10, 96(a1) // 加载保存寄存器s10
  ld s11, 104(a1) // 加载保存寄存器s11
  // 寄存器加载完成，现在已经切换到新的上下文
  // 栈指针和返回地址已改变，继续执行将进入新的执行流

  ret           // 从函数返回
  // 注意：这里不会返回到原始调用者
  // 而是返回到新的ra指定的地址
  // 这实现了执行流的跳转